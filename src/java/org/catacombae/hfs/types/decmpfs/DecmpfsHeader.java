/*-
 * Copyright (C) 2014-2015 Erik Larsson
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.catacombae.hfs.types.decmpfs;

import java.io.PrintStream;
import java.math.BigInteger;
import org.catacombae.csjc.PrintableStruct;
import org.catacombae.util.Util;

/** This class was generated by CStructToJavaClass. */
public class DecmpfsHeader implements PrintableStruct {
    /*
     * struct DecmpfsHeader
     * size: 16 bytes
     * description:
     *
     * BP  Size  Type  Identifier       Description
     * --------------------------------------------
     * 0   4     le32  magic
     * 4   4     le32  compressionType
     * 8   8     le64  fileSize
     */

    /** Proper value for 'magic' (this is "cmpf" in ASCII). */
    public static final long MAGIC = 0x636D7066L;

    public static final int COMPRESSION_TYPE_INLINE = 3;
    public static final int COMPRESSION_TYPE_RESOURCE = 4;

    public static final int STRUCTSIZE = 16;

    private int magic;
    private int compressionType;
    private long fileSize;

    public DecmpfsHeader(byte[] data, int offset) {
        this.magic = Util.readIntBE(data, offset+0);
        this.compressionType = Util.readIntBE(data, offset+4);
        this.fileSize = Util.readLongBE(data, offset+8);
    }

    public static int length() { return STRUCTSIZE; }

    /**  */
    public final long getMagic() { return Util.unsign(getRawMagic()); }

    /**  */
    public final long getCompressionType() { return Util.unsign(getRawCompressionType()); }

    /**  */
    public final BigInteger getFileSize() { return Util.unsign(getRawFileSize()); }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final int getRawMagic() { return Util.byteSwap(this.magic); }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final int getRawCompressionType() { return Util.byteSwap(this.compressionType); }

    /**
     * <b>Note that the return value from this function should be interpreted as
     * an unsigned integer, for instance using Util.unsign(...).</b>
     */
    public final long getRawFileSize() { return Util.byteSwap(this.fileSize); }

    public void printFields(PrintStream ps, String prefix) {
        ps.println(prefix + " magic: " + getMagic());
        ps.println(prefix + " compressionType: " + getCompressionType());
        ps.println(prefix + " fileSize: " + getFileSize());
    }

    public void print(PrintStream ps, String prefix) {
        ps.println(prefix + "DecmpfsHeader:");
        printFields(ps, prefix);
    }

    public byte[] getBytes() {
        byte[] result = new byte[length()];
        getBytes(result, 0);
        return result;
    }

    public int getBytes(byte[] result, int offset) {
        final int startOffset = offset;

        Util.arrayPutBE(result, offset, this.magic); offset += 4;
        Util.arrayPutBE(result, offset, this.compressionType); offset += 4;
        Util.arrayPutBE(result, offset, this.fileSize); offset += 8;

        return offset - startOffset;
    }
}
